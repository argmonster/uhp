'uScript Hypertext Processor
'This function will process an HTML template giving uscript access to input variables
' and create dynamic page content with db/dst/dct lookups.
'-----------------------------------------------------------------------------------------
'Fake Version String:
'
' version 3.3 07/26/2012 Tim Markello
' Copyright 9/2/2011 Tim Markello timmarkello@gmail.com
'
'-----------------------------------------------------------------------------------------
'Edits:
' Who:
'  Tim - Tim Markello
'  RLE - Robert Edeker
'
' Tim 9/23/2011 1.2.0 *Minor Version Change*
' + Server Side tag attribute access.
'     See below for details on using this feature
' + enhanced DCT control for check and radio lists
' + enhanced <block> to allow array variables to be switches
' ~ changed <block> to not use system function $BLOCK() due to argument limitations
' + New Tags:
'  + <print />
'  + <snap />
' Tim 9/27/11 .1 *bug fix found by Ralph W.
' + added $uc when comparing input type to ensure correct comparison.
'
' Tim 10/31/11 1.3.0 *Minor Version Change*
' + added uhp tag support for <literal> tags to allow dynamic input content
'  + passing a 'uhp' tag to the value of the literal tag will cause
'     uhp to (re)process the tag. 
'  + tweaked _TAGFIND subroutine to handle literal tag re-process
' + added maptag to uscript input functions 'style' argument. to allow selecting using
'  jquery selector. BUT since this doesn't seem to work in IE, it should probably be
'  removed in favor of $assignobj(maptag) so jquery isn't required for lookups
' + New Tag: <varedit /> - template tag for $editmsg()
'
' RLE 11/02/2011 1.3.1
'  + added TEXTBOX tag as an alias to TEXT
'  + added html-compliant SIZE and MAXLENGTH attributes for the $textbox() call
'
' ** Version 2.0 **
' Tim 01/11/2012 2.0 *Major Version Change*
' + Re worked the MAPPING Routines to allow mapping to 2d arrays
' + Added <library> tag
'
' Tim 02/01/2012 2.1 *Minor Version Update*
' + Changed uhp() argument from uhp.path -> uhp.arg[]. This allows you to pass an array 
'     containing the template that you would like uhp to process
' + Added lib-var[] and set-vals[] variables for <library>
'     These values let the called <library> set default values of variables pointed to in the
'     mainscript. lib-var[] should return a | delimited list of this format:
'        variable name|x-idx|y-idx
'     x-idx and y-idx are handled similar to other areas of uhp
'     The corrisponding value in set-vals[] is copied to the variable pointed to be lib-var[]
' + Added 'ADDOTHER', 'ADDOTHERTEXT', 'ADDOTHERTEXTIDX', 'ADDOTHERTEXTIDX2' and 'ADDOTHERTEXTEDIT'
'     attributes to <select>
' + Added multiple value support to <literal>: 
'     <literal> now handles uhp values that get squished into | string with dct edits
' ~ fixed some issues with _BLOCK id generation in <block>, <select> and <input>
' ~ fixed <literal> edittype='dst' attribute to allow dst names in upper or lowercase
' ~ fixed issue with loosing values when a <literal> contains a <literal> (saveA[] added)
' ~ fixed _MAPOUT Routine to allow NULL values to be mapped back to mainscript
' ~ fixed issue of finding end of tag with tags that contain '/' in attribute values
' ~ changed some $num() to $casti()
'*version 3.0*
' Tim 4/25/12 3.0
' ~ re work of parser to use $parse instead of $find
' ~ re work of literal tag edits to accept any system / uscript edit
' + added dot notation functionality for 1 and 2 diminsion arrays
' - variable cleanup
'*version 3.1
' Tim 4/30/12 3.1
' + added inherant indirect variable referencing from tag attribute values to variables in main script
'     use the '@' + 'varname' to indicate that the value of the attribute should contain the value of the variable
'     in the mainscript with the matching variable name.
' + add $checkoutput() checking to input values being mapped out to the mainscrip. Fixes issues with "<" in an input
'     value that is then displayed as a <literal> for a report / snapshot screen.
' Tim 6/20/12 3.2
' + added rptdate, rpttime, and scriptid attributes to <snap />. Values passed will be updated to $$doc.ddt, $$doc.dtm and
'     $$doc.app respectively. If no values are passed to the attributes $today, $timenow and $scriptid will be defaulted.
' Tim 7/26/12 3.3 *greater than bug fix*
' + added _NOPARSE subroutine to allow tags that will never have children tags that may need parsing to skip the parsing
'     routines until the corresponding closing tag is found. This subroutine can optionally $ctag the file lines or not
'     by setting the 'skip' variable in the _TAGPROC subroutine.
'
'     **This fixes the 'greater than' bug by bypassing the parsing of the contents of <script> tags.
' + tags currently set to _NOPARSE = <script>, <style>, and <head>
' ~ re arranged the select cases in _TAGPROC
'-----------------------------------------------------------------------------------------
'General Use Info:
'
' Due to the nature of the variable mapping this function MUST be an include file. Moving
'  this functionality to a library will break the variable mapping.
'
' This function uses the 'custom' attribute "uhp" to map the html values back to the
'  uScript variables. The uhp attribute value must match a variable name defined in the
'  main script that invokes this function or the value will be lost. Attribute to
'  variable mapping is NOT case sensitive. 
'   Example: 
'     Template attribute: ... uhp="client" ...
'     uScript: ... client is x ...
' 
' The HTML processing can parse attribute values wrapped with either a ' (single quote) 
'  or a " (double quote) BUT the closing wrapper MUST MATCH the open wrapper
'   Example: ... att='value' ... or ... att="value" ... *GOOD
'            ... att="value' ... or ... att='value" ... **NO GOOD!!
'
' Any HTML tag that is not supported by uhp will be sent to the browser for display AS IS.
'  This processor does not validate HTML other then the specific uhp tags.
'
'-----------------------------------------------------------------------------------------
'UHP Tags
'  
'  <BODY>
'     + creates the form to send to browser
'     Attributes:
'        Submitopt=<"on"/"off">
'           + optional
'           + adds the submit button to form or not
'           + defaults to "on"
'        SubmitLabel=<string>
'           + optional
'           + sets label of submit button to <string>
'           + defaults to 'SUBMIT'
'        CancelOpt=<"on"/"off">
'           + optional
'           + adds the cancel button to form or not
'           + defaults to "on"
'        CancelLabel=<string>
'           + optional
'           + sets label of cancel button to <string>
'           + defaults to 'CANCEL'
'        FormName=<string>
'           + optional
'           + sets formname to <string>
'           + defaults to user id + time of execution
'  <INPUT>
'     Attributes:
'        uhp=<string>
'           + required
'           + maps ui to uscript variable <string>
'        type=<"text"/"submit"/"checkbox"/"radio">
'           + required
'           + determins the input control behavor
'  <TEXTBLOCK>
'  <SELECT>
'     <OPTION>
'  <BLOCK>
'  <LITERAL>
'  <print />
'     Creates javascript print button on the form same as c_pbutton system include
'        but does not need c_cldef / c_clget includes
'     Attribures: None
'  <snap />
'     Creates cmhc snapshot, adding signature lines as configred in irms.
'     ***NOTE*** 
'        you must use inc_sysLibDef include in your mainscript for this tag to work.
'        Not using this inc will cause the script to crash if the template contains a
'        <snap> tag
'     **********
'     Attributes:
'        Title=<form title>
'           + title of the form - this is what will display in the irms viewer
'        Option=<snapshot option>
'           + 'option' argument to sn_CreateReport function. I'm not sure what the options are
'        parmfile=<snapshot Parmfile>
'           + 'parmfile' argument to sn_CreateReport function. I'm not suer what the parm options are
'        formid=<IRMSFormID>
'           + required
'           + form ID. must be a IRMS defined form. 
'           + ***NOTE*** UHP does not currently check to see if this is a valid IRMS form. an undefined
'              /invalid form id will display an error at the bottom of the form
'        regid=<RegisterID>
'           + register id to tie to the snapshot
'           + value of regid attribute can be a variable in the mainscript. The value of the variable
'              is used as the argument to the sn_CreateReport function. If a variable name matching
'              the value of the regid attribute is not found the actuall attribute value is passed
'              as the sn_CreateReport function.
'        dbnum='DB-Nbr'
'           + mis db number corrisponding with regid attribute.
'-----------------------------------------------------------------------------------------
' uScript / Server side access to template tag attributes
'  uhp allows uScript to access / change html tag attributes defined on the html template.
'     This is designed to allow the template attributes to dynamically changed based on
'     uScript logic.
'
'  To use this feature you must declare a variable using the following variable naming convention:
'     <variable name>.<attribute name>
'
'  The <variable name> must be the variable defined on the template tag with the 'uhp' 
'     attribute. For tags that are imbedded inside of other 'uhp' tags you will need to
'     include all of the variable names in the attribute prefix:
'        <outer var name>.<inner var name>.<att name>
'     This variable naming convention would be repeated for every level of tag embedding.
'
'  To change a template attribute use an assign statement to set the conventionally named
'     variable to the new attribute value before calling the uhp function.
'
'  To remove the value of the attribute without setting a new value in the uScript you must
'     set the uScript variable to "NULL" (myExmple.myAttribute = "NULL")
'
'  Example:
'     uScript:
'        start exampleScript()
'        uhpVar         is x
'        uhpVar.label   is x
'        uhpVar.label = "different from the template"
'        uhp("path/to/template")
'        end exampleScript
'     Template:
'        <html>
'           <body>
'              <input type='text' uhp='uhpVar' label='Set on Template' />
'           </body>
'        </html>
'
'  ***NOTE***
'     uScript limits the length of variable names to 16 characters - so plan accordingly
'     if you plan on using multiple layers of tag embedding and need to access the attributes.
'     (keep the var names short)
'
'-----------------------------------------------------------------------------------------
'Due to recursion limitations inherent with uScript this function uses subroutines to
' loop through the nested HTML tags in the template. Not pretty but it works.
'
'uhp recursion map
'
'start template file read
'  |
'  `-> Find HTML Tag <-.
'  |     |             |
'  |     `-> proc tag -'
'  |
'  `--> End of template file
'---------------------------
dynamic function uhp(uhp.arg[]) is b
 'argument
uhp.arg[]      is x
 'template file variables
uhp.path       is x     'path of the html template for processing
uhp.handle     is b
uhp.line       is x
uhp.file[]     is x
uhp.cnt        is b
uhp.max        is b
 'uscript html control variables
varptr         is b     'variable pointer for variables in main script
copyptr        is b     'variable pointer for uhp-variables to copy main script vars to
varlist[]      is x     'list of variable names for this script indexed by variable pointer. MAKE GLOBAL??
main[,]        is x     'holder for copying variable to and from 'main'script
control[,]     is x     'generic internal uhp variable for storing html control values
map[,]         is x     'table to map variable pointer and x,y indicies to uhp control variable
mapFlag[]      is x     'flags variable of mainscript to ensure mapping
contptr        is b     'current control index
conttot        is b     'total number of controls on this template
idxptr         is b     'mapping x index
idx2ptr        is b     'mapping y index
formName       is x
 'template parsing variables
tagStart       is x
openTag        is x
currentptr     is b
linelen        is b
tagtype        is x
tagend         is x     'character that ends the current tag: indicates if the tag is standalone (... />) or contains children (... >)
notag          is x     'not a uhp tag - sent to browser 'as is' from template
attName[]      is x
attValue[]     is x
attWrap        is x
wrap           is x
delim          is x
delimend       is x
inputMap       is x     'value from tag attribute 'uhp' : name of variable to map to in main script
value[]        is x
label[]        is x
pbutton        is x
dotnote        is x
 'uhp recursion variables
parenttag[]    is x
parentAtt[]    is x
parentAttNam[,]   is x
parentAttVal[,]   is x
parentptr      is b
 'dst processing variables
dstinfo[]      is x
dstlist        is dstlist
dstval[]       is x
dstname[]      is x
'fakerecord     is h
'fakedst        is v
 'for dynamic processing
saveLine[]     is x
saveOpen[]     is b
saveClose[]    is b
saveTag[]      is x
saveCnt[]      is b
saveptr        is b
saveVal[]      is x
saveT[,]       is x
saveA[,]       is x
 'library module
lib-return[]   is x
lib-var[]      is x
lib-val[]      is x
templib        is b
'for saving focus
'focusid        is x       'may do something with ??
 'misc/temp counters & strings 
i              is b
tempNum        is b
temp[]         is x
skip           is x
string         is x
loopcount      is b
looplimit      is b
'-----------------------------------
'MAIN:
'-----------------------------------
$clear(uhp.handle, uhp.line, varptr, control[], temp[], string, parenttag[],parentatt[],map[])
'save off the loops variables
loopcount = $loopcount
looplimit = $looplimit
$loopcount = 0
$looplimit = 99999 'change to 0?
contPtr = 0
contTot = 0
'process the argument
if $argusage(uhp.arg[]) = 3 then  'passed in as array
   if $tempfile(uhp.path) > 0 then
      uhp = 1
      return
   elseif $putfile(uhp.arg[], uhp.path) > 0 then
      uhp = 1
      return
   endif
else     'simple variable or constant
   uhp.path = uhp.arg[]
endif
'### alternative file loading method ###
'if $getfile(uhp.file[], uhp.path) > 0 then
'   uhp = 1 
'   return
'endif
'tagstart = "<"
'uhp.cnt = 0
'uhp.max = $maxarray(uhp.file[])
'do while uhp.cnt++ < uhp.max
'   uhp.line = uhp.file[uhp.cnt]
'   currentptr = 1
'   linelen = $len(uhp.line) + 1
'   gosub _TAGFIND
'enddo
'#######################################
'open and process template
uhp.handle = $fileavail()
if $openfile(uhp.handle, uhp.path, "I") > 0 then
   uhp = 1
   return
endif
tagStart = "<"
do while $readfile(uhp.handle, uhp.Line) = 0
   currentptr = 1
   lineLen = $len(uhp.line) + 1
   gosub _TAGFIND
enddo
(void)$closefile(uhp.handle)
'map variables back to main script
gosub _MAPOUT
'reset looplimits
$looplimit = looplimit
$loopcount = loopcount
'-------------------------------------
' return control back to main script
'-------------------------------------
return
'-------------------------------------
' Subroutines after this point
'-------------------------------------
' get the next line
'-------------------------------------
_NEXTLINE:
   if saveLine[] !dp then
      currentptr = 1
'### alternative file loading method ###
'      if ++uhp.cnt > uhp.max then
'         uhp = 2
'         return
'      endif
'      uhp.line = uhp.file[uhp.cnt]
'#######################################
      if $readfile(uhp.handle, uhp.line) > 0 then
         uhp = 2
         (void)$closefile(uhp.handle)  'don't leave a mess
         return
      endif
      lineLen = $len(uhp.line) + 1
   endif
goback 
'-------------------------------------
' Find the next uhp tag to process
'-------------------------------------
_TAGFIND:
   if uhp.line dp then
      do while currentptr < lineLen
         if currentptr = 0 then currentptr = 1 endif
         notag = $parse(uhp.line, currentptr, tagStart, delimend)
         if notag dp and skip != "Y" then $ctag($replace(x"0d", "<br />", notag)) endif
         if delimend = "<" then
            $clear(tagtype, attName[], attValue[])
            delim = " =>"
            tagend = ">"
            opentag = "<"
            string = ""
            delimend = ""
            tempnum = 0
            i = 0
            do until delimEnd = ">"
               string += $parse(uhp.line, currentptr, delim, delimEnd)
               opentag += string + delimend
               select delimEnd
                  case " "    if currentptr < lineLen then
                                 tagtype = $trim($uc(string))
                                 delim = $replace(" ", "", delim)
                                 if $find("/", string,1,"F") > 0 then tagend = "/" endif
                                 $clear(string)
                              else
                                 gosub _NEXTLINE
                              endif
                              opentag += " "
                  case "="    attName[++i] = $trim($uc(string))
                              $clear(string)
                              delim = wrap
                  case "'"
                    or x"22"  if tempnum > 0 then
                                 attValue[i] = string
                                 tempnum = 0
                                 delim = "=>"
                              else
                                 tempnum++
                                 delim = delimEnd
                              endif
                              $clear(string)
                  case ">"    if tagtype !dp then tagtype = $trim($uc(string)) endif
                              if $find("/", string,1,"F") > 0 then tagend = "/" endif
               endselect
            enddo
            gosub _TAGPROC
         endif
      enddo
   endif
goback


'-------------------------------------
' Process the uhp tag
'-------------------------------------
_TAGPROC:
   i = 2
   select $uc(tagtype)
      case "INPUT"      gosub _INPUT
                        tagend = "/"
      case "SELECT"     gosub _DROPBOX
      case "OPTION"     gosub _DROPBOXOPT
      case "TEXTBLOCK"  gosub _TEXTBLOCK
      case "BLOCK"      gosub _BLOCK
                        tagend = "/"
      case "/BLOCK"     gosub _ENDBLOCK
      case "LITERAL"    gosub _LITERAL
      case "PRINT"      gosub _PBUTTON
      case "SNAP"       gosub _SNAPSHOT
      case "LIBRARY"    gosub _LIBRARY
      case "VAREDIT"    gosub _VAREDIT
      case "BODY"       gosub _BODYTAG
                        tagend = "/"
      case "/BODY"      $sendform(formName)
                        tagend = "/"
      case "SCRIPT"     gosub _NOPARSE
      case "STYLE"      gosub _NOPARSE
      case "HTML"
        or "/HTML"      'do nothing
                        tagend = "/"
      case "HEAD"       skip = "Y"
                        gosub _NOPARSE
      case "!--"        'do nothing
                        tagend = "/"
      case other        $ctag(opentag)
                        tagend = "/"
   endselect
   'go find the child tags if there are some
   if tagEnd = ">" then
      parentTag[++parentptr] = tagtype
      parentAttNam[parentptr] = attName[]
      parentAttVal[parentptr] = attValue[]
      string = "/" + parentTag[parentptr]
      do while tagtype != string
         if currentptr < lineLen then
            gosub _TAGFIND
         else
            gosub _NEXTLINE
         endif
         string = "/" + parentTag[parentptr]
      enddo
      tagtype = parentTag[parentptr]
      attName[] = parentAttNam[parentptr]
      attValue[] = parentAttVal[parentptr]
      (void)$arrRemove(parentTag[parentptr])
      (void)$arrRemove(parentAttVal[parentptr])
      (void)$arrRemove(parentAttNam[parentptr])
      --parentptr
   endif

goback

'-------------------------------------
'-------------------------------------
_NOPARSE:
   if skip != "Y" then $ctag(opentag) endif
   tagtype = "</" + tagtype + ">"
   string = $uc(uhp.line)                          'cache the upper case line because $find has issues with executable
   i = $find(tagtype, string, currentptr, "F")     'strings in argument 2 (seems to return partial matches)
   if i = 0 then
      i = linelen - currentptr
      string = $seg(uhp.line, currentptr, i)
      i = 0
      if skip != "Y" then $ctag(string) endif
      gosub _NEXTLINE
      do while i = 0
         if skip != "Y" then $ctag(uhp.line) endif
         gosub _NEXTLINE
         string = $uc(uhp.line)
         i = $find(tagtype, string, currentptr, "F")
      enddo
   endif
   i += 9   'end of script
   i = i - currentptr
   string = $seg(uhp.line, currentptr, i)
   if skip != "Y" then $ctag(string) endif
   currentptr += i++
   tagend = "/"
   skip = "N"
goback


'-------------------------------------
' the uhp input tag
'-------------------------------------
_INPUT:
   $clear(temp[], dotnote)
   gosub _MAPIN
   temp[1] = getAttVal("TYPE", attName[], attValue[], varlist[], dotnote)
   string = getAttVal("ID", attName[], attValue[], varlist[], dotnote)
   if string dp then
      (void)$assignobj(string)
   endif
   select $uc(temp[1])
      case "FILE"    'insert the rmi junk?
                     string = "<input type='file' id='" + string + "' ></input>"
                     $ctag(string)
      case "TEXT"    temp[2] = getAttVal("LABEL", attName[], attValue[], varlist[], dotnote)
                     if temp[2] dp then
                        $text(temp[2])
                     endif
                     temp[3] = getAttVal("EDIT", attName[], attValue[], varlist[], dotnote)
                     temp[4] = getAttVal("MAX-CHARS", attName[], attValue[], varlist[], dotnote)
                     if temp[4] !dp then 
                        temp[4] = "9999"
                     endif
                     temp[5] = getAttVal("WIDTH", attName[], attValue[], varlist[], dotnote)
                     temp[6] = getAttVal("REQ", attName[], attValue[], varlist[], dotnote)
                     $textbox(control[contptr], temp[3],$casti(temp[4]),$casti(temp[5]),temp[6],inputmap)
      case "SUBMIT"  temp[2] = getAttVal("VALUE", attName[], attValue[], varlist[], dotnote)
                     temp[3] = getAttVal("CLASSSEL", attName[], attValue[], varlist[], dotnote)
                     temp[4] = getAttVal("CLASSNOTSEL", attName[], attValue[], varlist[], dotnote)
                     if (temp[3] dp and temp[4] dp) then 'or temp[4] dp then
                        $bstyle(temp[3], temp[4])
                     endif
                     $submit(control[contptr], temp[2])
      case "RADIO"   
        or "CHECKBOX"   string = getAttVal("DCT", attName[], attValue[], varlist[], dotnote)
                        if string dp then
                           $clear(value[], label[])
                           tempNum = $num(string)
                           (void)$dctload(tempNum, value[], label[])
                           'do we want a specific item?
                           string = getAttVal("CODE", attName[], attValue[], varlist[], dotnote)
                           if string dp then
                              i = $find(string, value[], 1, "F")
                              tempNum = i + 1
                           else
                              i = 1
                              tempNum = $maxarray(value[]) + 1
                           endif
                           if idxptr !dp then
                              idxptr = i
                           endif
                        else
                           'defined on the template
                           value[1] = getAttVal("VALUE", attName[], attValue[], varlist[], dotnote)
                           label[1] = getAttVal("LABEL", attName[], attValue[], varlist[], dotnote)
                           i = 1
                           tempNum = 2
                        endif
                        do while i < tempNum
                           string = $uc(inputMap) + "-" + $uc(value[i]) + "-" + idxptr + "-" + idx2ptr
                           if $uc(temp[1]) = "RADIO" then
                              $radio(control[contptr], label[i], value[i],,,string,string,inputmap)
                           else
                              $checkbox(control[contptr,i], label[i], value[i],,,string,string,inputmap)
                              idxptr++
                           endif
                           i++
                        enddo
   endselect
goback

'-------------------------------------
' the uhp select/drop down list tag
'-------------------------------------
_DROPBOX:
   $clear(value[],label[],dotnote)
   gosub _MAPIN
   string = getAttVal("DCT", attName[], attValue[], varlist[], dotnote)
   if string dp then
      tempnum = $num(string)
      (void)$dctload(tempNum, value[], label[])
   endif
   string = getAttVal("LISTVAL", attName[], attValue[], varlist[], dotnote)
   if string dp then
      tempnum = findVar(string, varlist[])
      copyptr = $varptr(value[])
      (void)$copyvar(tempnum, copyptr)
   endif
   string = getAttVal("LISTLABEL", attName[], attValue[], varlist[], dotnote)
   if string dp then
      tempnum = findVar(string, varlist[])
      copyptr = $varptr(label[])
      (void)$copyvar(tempnum,copyptr)
   endif
   string = getAttVal("ADDOTHER", attName[], attValue[], varlist[], dotnote)
   if $uc(string) = "Y" then string = $maxarray(Value[]) + 1 endif
   i = $casti(string)
   if i > 0 then
      (void)$arrInsert(value[i], "OTHER")
      (void)$arrInsert(Label[i], "Other")
   endif
   string = getAttVal("ADDBLANK", attName[], attValue[], varlist[], dotnote)
   if string = "Y" then
      (void)$arrInsert(value[1],"")
      (void)$arrInsert(label[1],"")
   endif
   string = getAttVal("ID", attName[], attValue[], varlist[], dotnote)
   if string dp then
      (void)$assignobj(string)
   endif
   i = 0
   do while i++ < $maxarray(value[], label[])
      string = $uc(inputMap) + "-" + $uc(value[i]) + "-" + idxptr + "-" + idx2ptr
      $dropbox(control[contptr], label[i], value[i],,,string, string)
   enddo
   temp[1] = getAttVal("ADDOTHERTEXT", attName[], attValue[], varlist[], dotnote)
   if temp[1] dp then
      temp[2] = getattval("ADDOTHERTEXTIDX", attName[], attValue[], varlist[], dotnote)
      temp[3] = getattval("ADDOTHERTEXTIDX2", attName[], attValue[], varlist[], dotnote)
      temp[4] = getattval("ADDOTHERTEXTEDIT", attName[], attValue[], varlist[], dotnote)
      string = "<block uhp='" + inputmap + "' value='OTHER' idx='" + idxptr + "' idx2='" + idx2ptr + "'>"
             + "<input type='text' uhp='" + temp[1] + "' idx='" + temp[2] + "' idx2='" + temp[3] + "' edit='"
             + temp[4] + "' /></block>"
      gosub _REPROC
   endif
goback

'-------------------------------------
' the uhp drop down list option tag
'-------------------------------------
_DROPBOXOPT:
   i++
   $clear(temp[],dotnote)
   (void)$arrInsert(attName[1], parentAttNam[parentptr])
   (void)$arrInsert(attValue[1], parentAttval[parentptr])
   temp[1] = getAttVal("VALUE", attName[], attValue[], varlist[], dotnote)
   temp[2] = getAttVal("LABEL", attName[], attValue[], varlist[], dotnote)
   string = $uc(inputMap) + "-" + $uc(temp[1]) + "-" + i
   $dropbox(control[contptr], temp[2], temp[1],,,string,string)
goback

'-------------------------------------
' the uhp hidden block open tag
'-------------------------------------
_BLOCK:
   $clear(temp[],tempnum, dotnote)
   temp[1] = getAttVal("UHP", attName[], attValue[], varlist[], dotnote)
   temp[2] = getAttVal("VALUE", attName[], attValue[], varlist[], dotnote)
   temp[3] = getAttval("IDX", attName[], attValue[], varlist[], dotnote)
   idxptr = $num(temp[3])
   temp[4] = getAttval("IDX2", attName[], attValue[], varlist[], dotnote)
   temp[9] = getAttval("DISPTYPE", attName[], attValue[], varlist[], dotnote)
   if temp[9] !dp then temp[9] = "block" endif
   idx2ptr = $num(temp[4])
   varptr = findvar(temp[1], varList[])
   copyptr = $varptr(main[])
   (void)$copyvar(varptr, copyptr)
   if idx2ptr dp then
      string = main[idxptr, idx2ptr]
   else
      string = main[1,idxptr]
   endif
   if string = temp[2] then
      temp[6] = temp[9]
   else
      temp[6] = "none"
   endif
   temp[8] = getAttVal("CLASS",attName[],attValue[],varlist[], dotnote)
   string = temp[1] + "-" + temp[2] + "-" + temp[3] + "-" + temp[4]
   string = "<span id='scrBlock" + $uc(string) + $uc(string) + "' class='" + temp[8] + "' style='display:" + temp[6] + "'>"
   $ctag(string)

goback

'-------------------------------------
' the uhp hidden block close tag
'-------------------------------------
_ENDBLOCK:
   $ctag("</span>")
goback

'-------------------------------------
' the uhp body tag
'-------------------------------------
_BODYTAG:
   $clear(temp[], dotnote)
   temp[1] = getAttVal("SUBMITOPT", attName[], attValue[], varlist[], dotnote)
   temp[2] = getAttVal("SUBMITLABEL", attName[], attValue[], varlist[], dotnote)
   temp[3] = getAttVal("CANCELOPT", attName[], attValue[], varlist[], dotnote)
   temp[4] = getAttVal("CANCELLABEL", attName[], attValue[], varlist[], dotnote)
   temp[5] = getAttVal("CLASS", attName[], attValue[], varlist[], dotnote)
   formname = getAttVal("NAME", attName[], attValue[], varlist[], dotnote)
   if formname !dp then
      formname = $oper + $timenow
   endif
   if temp[1] !dp then
      temp[1] = "off"
   endif
   if temp[3] !dp then
      temp[3] = "off"
   endif
   if temp[2] !dp then
      temp[2] = "Submit"
   elseif temp[2] = "NULL" then
      $clear(temp[2])
   endif
   if temp[4] !dp then
      temp[4] = "Cancel"
   elseif temp[4] = "NULL" then
      $clear(temp[4])
   endif
   $submitopt(temp[1], temp[2])
   $cancelopt(temp[3], temp[4])
   $form(formName, temp[5])
goback

'-------------------------------------
' the uhp textblock tag
'-------------------------------------
_TEXTBLOCK:
   $clear(temp[], dotnote)
   gosub _MAPIN
   temp[1] = getAttVal("LABEL", attName[], attValue[], varlist[], dotnote)
   temp[2] = getAttVal("COL", attName[], attValue[], varlist[], dotnote)
   temp[3] = getAttVal("ROW", attName[], attValue[], varlist[], dotnote)
   temp[4] = getAttVal("LIMIT", attName[], attValue[], varlist[], dotnote)
   temp[5] = getAttVal("CLASS", attName[], attValue[], varlist[], dotnote)
   temp[6] = getAttVal("ID", attName[], attValue[], varlist[], dotnote)
   if temp[5] dp then 
      temp[5] = "class='" + temp[5] + "'" 
   endif
   $text(temp[1])
   if temp[6] dp then
      (void)$assignobj(temp[6])
   endif
   $textblock(control[contptr], $casti(temp[3]), $casti(temp[2]), temp[5],,$casti(temp[4]))
goback

'-------------------------------------
' the uhp literal tag
'-------------------------------------
_LITERAL:
   $clear(temp[], value[], saveVal[],main[], dotnote)
   temp[3] = getAttVal("VALUE", attName[], attValue[], varlist[], dotnote)[]
   temp[1] =  getAttVal("EDITTYPE", attName[], attValue[], varlist[], dotnote)
   temp[2] = getAttVal("EDITNUM", attName[], attValue[], varlist[], dotnote)
   temp[4] = getAttVal("CLASS", attName[], attValue[], varlist[], dotnote)
   temp[5] = getAttVal("OPTION", attName[], attValue[], varlist[], dotnote)
   temp[6] = getAttVal("IDX", attName[], attValue[], varlist[], dotnote)
   idxptr = $num(temp[6])
   temp[7] = getAttVal("IDX2", attName[], attValue[], varlist[], dotnote)
   idx2ptr = $num(temp[7])
   varptr = findVar(temp[3], varlist[])
   if varptr > 0 then
      copyptr = $varptr(main[])
      (void)$copyvar(varptr,copyptr)
      if idx2ptr dp then
         if idxptr dp then
            saveVal[1] = main[idxptr, idx2ptr]
         else
            saveVal[] = main[idx2ptr]
         endif
      else
         saveVal[] = main[1,idxptr]
      endif
   else
      saveVal[1] = temp[3]
   endif
   $parsem($uc(temp[1]),1,"`",temp[11],,temp[12],temp[13],temp[14])
   if temp[12] !dp then temp[12] = $uc(temp[2]) endif
   if $uc(temp[1]) = "SAC" then temp[1] = "SAM" endif 'make original implimentation compatable with system edits.
   if $uc(temp[1]) = "DB" then temp[1] = "DB``" + temp[2] endif
   i = 0
   do while i++ < $maxarray(saveVal[])
      string = saveVal[i]
      select $uc(temp[11])
         case "DCT"     tempnum = 1
                        temp[8] = $parse(string, tempnum, "|")
                        do while tempnum < $len(string) or temp[8] dp
                           temp[9] = $dct($casti(temp[12]), temp[8], temp[5])
                           if temp[8] dp and temp[10] dp then
                              temp[10] += ", "
                           endif
                           if temp[9] dp then
                              temp[10] += temp[9]
                           else
                              temp[10] += temp[8]
                           endif
                           temp[8] = $parse(string, tempnum, "|")
                        enddo
                        string = temp[10]
         case "DST"     dstname[2] = temp[12]
                        (void)$dstinfo(temp[12], dstinfo[])
                        if dstinfo[16] dp then dstname[1] = dstinfo[16] endif
                        if temp[13] !dp then temp[13] = 1 endif
                        if temp[14] !dp then temp[14] = ", " endif
                        tempnum = 1 'set the layercounter
                        (void)$dstlist(dstlist, $num(dstinfo[4]), dstname[], dstval[])
                        if $dbread($num(dstinfo[4]), string, dstlist) > 1 then
                           temp[13] = tempnum
                        endif
                        do until tempnum++ = $num(temp[13])
                           if temp[13] = "ALL" then
                              if temp[15] dp and dstval[2] dp then temp[15] += temp[14] endif
                              temp[15] += dstval[2]
                           endif
                           if $dbreadnextdst($num(dstinfo[4]), string, dstlist) > 1 then
                              temp[13] = tempnum
                           endif
                        enddo
                        if temp[15] dp and dstval[2] dp then temp[15] += temp[14] endif
                        string = temp[15] + dstval[2]
         case other     if temp[11] dp then (void)$getEditMsg(string, temp[1], string) endif
      endselect
      'let's process the new stuff!!
      if string dp then
         gosub _REPROC
      endif
   enddo
goback

'-------------------------------------
' the print button tag
'-------------------------------------
_PBUTTON:
   string = "<button type='button' class=sigbutton id=printbutton style='DISPLAY: block' "
   string += "onclick=window.print(); cmhcType='script' classSel='sigbutton' classNotSel='sigbutton'>"
   string += "Print</button>"
   $ctag(string)
   $ctag(pbutton)
%preload pbutton line-ending(cr)
<SCRIPT>
var prnPrintBtnDisp;
function window.onbeforeprint(){
   prnPrintBtnDisp=document.all.printbutton.style.display;
   document.all.printbutton.style.display="none";
   if(this.document.all.sessiontabs != null) this.document.all.sessiontabs.style.display='none';
   }
function window.onafterprint(){
   document.all.printbutton.style.display=prnPrintBtnDisp;
   if(this.document.all.sessiontabs != null) this.document.all.sessiontabs.style.display='block';
   try{reportOnafterprint();}
   catch(e){}}
</SCRIPT>
%endpreload
       
goback

'-------------------------------------
' the Snapshot tag
'-------------------------------------
_SNAPSHOT:
   $clear(temp[], dotnote)
   inputMap = getAttVal("UHP", attName[], attValue[], varlist[], dotnote)
   temp[1] = getAttVal("TITLE", attName[], attValue[], varlist[], dotnote)
   temp[2] = getAttVal("OPTION", attName[], attValue[], varlist[], dotnote)
   temp[3] = getAttVal("PARMFILE", attName[], attValue[], varlist[], dotnote)
   temp[4] = getAttVal("FORMID", attName[], attValue[], varlist[], dotnote)
   temp[5] = getAttVal("REGID", attName[], attValue[], varlist[], dotnote)
   temp[7] = getAttVal("RPTDATE", attName[], attValue[], varlist[], dotnote)
   temp[8] = getAttVal("RPTTIME", attName[], attValue[], varlist[], dotnote)
   temp[9] = getAttVal("SCRIPTID", attName[], attValue[], varlist[], dotnote)
   temp[10] = getAttVal("SNAPID", attName[], attValue[], varlist[], dotnote)
   varptr = findVar(temp[5], varlist[])
   if varptr > 0 then
      copyptr = $varptr(string)
      (void)$copyvar(varptr, copyptr)
      temp[5] = string
   endif
   temp[6] = getAttVal("DBNUM", attName[], attValue[], varlist[], dotnote)
   if temp[4] dp and temp[6] dp then
      snap_handle:sn_CreateReport(temp[1], temp[2], temp[3], temp[4], temp[5], $num(temp[6]),,,temp[7],temp[8],temp[9]) 
   elseif temp[10] dp then
      snap_handle:sn_viewsnap(temp[10], "bigreport")
   else
      $ctag("ERROR-Unable to Ready Snap Shot")
   endif
goback

'-------------------------------------
' call a library's 'render' function
'-------------------------------------
_LIBRARY:
   $clear(dotnote)
   gosub _MAPIN
   i = 0
   do while i++ < $maxarray(attName[])
      attValue[i] = getAttVal(attName[i], attname[], attValue[], varlist[], dotnote)
      if attName[i] = "NAME" then
         string = attValue[i]
      endif
      if attName[i] = "IDX" then
         idxptr = $num(attValue[i])
      endif
   enddo
   templib = $num(control[contptr,1])
   if templib < 1 then
      (void)$loadlib(templib, string)
   endif
   'garbage gets shoved into control[contptr,>1] and I don't know why
   'clear the row and reset the library handle every time to workaround
   $clear(lib-return[], control[contptr],lib-var[], lib-val[])
   control[contptr,1] = templib
   'do something to make sure 'render()' is in the library?
   lib-return[] = templib:render(attName[], attValue[],lib-var[], lib-val[])[]
   i = 0
   do while i++ < $maxarray(lib-var[])
      $parsem(lib-var[i],1,"|",temp[])
      idxptr = $casti(temp[2])
      idx2ptr = $casti(temp[3])
      varptr = findVar(temp[1], varlist[])
      if varptr > 0 then
         copyptr = $varptr(main[])
         (void)$copyvar(varptr,copyptr)
         if idx2ptr > 0 then
            if idxptr > 0 then
               main[idxptr,idx2ptr] = lib-val[i]
            else
               main[idx2ptr] = lib-val[i]
            endif
         else
            main[1,idxptr] = lib-val[i]
         endif
         main[] = main[]
         (void)$copyvar(copyptr, varptr)
      endif
   enddo
   string = "<literal value='lib-return' />"
   gosub _REPROC
goback

'-------------------------------------
' display the $editmsg for a vairable
'-------------------------------------
_VAREDIT:
   $clear(dotnote)
   inputMap = getAttVal("UHP", attName[], attValue[], varlist[], dotnote)
   temp[1] = getAttVal("IDX", attName[], attValue[], varlist[], dotnote)
   idxptr = $num(temp[1])
   temp[2] = getAttVal("IDX2", attName[], attValue[], varlist[], dotnote)
   idx2ptr = $num(temp[2])
   varptr = findVar(inputMap, varlist[])
   if varptr > 0 then   'this is a variable from the main script
      string = "|" + $castx(idxptr) + "|" + $castx(idx2ptr) + "|"
      i = $find(string, map[varptr], 1, "P")
      if i > 0 then
         tempnum = $num($parse(map[varptr,i], 1, "|"))
      endif
   endif
   $editmsg(control[tempnum])
goback

'-------------------------------------
' Save off to approximate recursion
'-------------------------------------
_REPROC:
   saveLine[++saveptr] = uhp.line
   saveOpen[saveptr] = currentptr
   saveTag[saveptr] = tagtype
   saveT[saveptr] = saveVal[]
   saveA[saveptr] = temp[]
   saveCnt[saveptr] = i
   currentptr = 1
   uhp.line = string
   linelen = $len(uhp.line) + 1
   gosub _TAGFIND
   uhp.line = saveLine[saveptr]
   linelen = $len(uhp.line) + 1
   currentptr = saveOpen[saveptr]
   tagType = savetag[saveptr]
   saveVal[] = savet[saveptr]
   temp[] = saveA[saveptr]
   i = savecnt[saveptr]
   (void)$arrRemove(saveLine[saveptr])
   (void)$arrRemove(saveopen[saveptr])
   (void)$arrRemove(saveClose[saveptr])
   (void)$arrRemove(savetag[saveptr])
   $clear(saveT[saveptr],saveA[saveptr])
   saveptr--
goback

'-------------------------------------
' map variables from mainscript to uhp controls
'-------------------------------------
_MAPIN:
   inputMap = getAttVal("UHP", attName[], attValue[], varlist[], dotnote)
   temp[1] = getAttVal("IDX", attName[], attValue[], varlist[], dotnote)
   idxptr = $num(temp[1])
   temp[2] = getAttVal("IDX2", attName[], attValue[], varlist[], dotnote)
   idx2ptr = $num(temp[2])
   varptr = findVar(inputMap, varlist[])
   if varptr > 0 then   'this is a variable from the main script
      $clear(main[])
      mapflag[varptr] = "Y"
      copyptr = $varptr(main[])
      (void)$copyvar(varptr, copyptr) 'copy the variable over from the main script
      if idx2ptr > 0 then
         if idxptr > 0 then
            (void)$getds(temp[], main[idxptr,idx2ptr],"|")
         else
            temp[] = main[idx2ptr]
         endif
      else
         temp[] = main[1,idxptr]
      endif
      string = "|" + $castx(idxptr) + "|" + $castx(idx2ptr) + "|"
      i = $find(string, map[varptr], 1, "P")
      if i > 0 then
         contptr = $num($parse(map[varptr,i], 1, "|"))
      else
         contptr = ++conttot
         i = $maxarray(map[varptr]) + 1
         map[varptr,i] = $castx(contptr) + string
      endif
      if temp[] dp then
         control[contptr] = temp[]
      endif
   endif
goback

'-------------------------------------
' map uhp controls back to mainscript variables
'-------------------------------------
_MAPOUT:
   varptr = $find("Y", mapFlag[], 1, "F")
   do while varptr > 0
      $clear(temp[],main[])
      copyptr = $varptr(main[])
      i = $copyvar(varptr,copyptr)  'copy the var in so we don't loose stuff that doesn't get written this pass
      i = 0
      do while i++ < $maxarray(map[varptr])
         $parsem(map[varptr,i],1,"|",temp[])
         contptr = $num(temp[1])
         idxptr = $num(temp[2])
         idx2ptr = $num(temp[3])
         $clear(temp[],string) ',main[])
         temp[] = control[contptr]
         'if temp[] dp then
            if temp[] !dp or temp[] = "" then 
               $clear(temp[]) $clear(string) 
            else
               (void)$putds(temp[],string, x"00")
               string = $checkoutput(string)
               (void)$getds(temp[],string,x"00")
            endif
            if idx2ptr > 0 then
               if idxptr > 0 then
                  main[idxptr,idx2ptr] = string
               else
                  main[idx2ptr] = temp[]
               endif
            else
               if idxptr > 0 then
                  main[1,idxptr] = string
               else
                  main[1] = temp[]
               endif
            endif
        ' endif
      enddo
      main[] = main[]   '**some wierd quirk the $copyvar doesn't like to copy 2d array without direct assignment
      i = $copyvar(copyptr, varptr)
      varptr = $find("Y", mapFlag[], ++varptr, "F")
   enddo
goback


end uhp
'-------------------------------------
' support functions after this point
'-------------------------------------
' put uhp tag attributes and values 
' into arrays
'-------------------------------------
dynamic function getAtts(attString, name[], value[]) is null
attString   is x
name[]      is x
value[]     is x

attList[]   is x
i           is b
cnt         is b
wrapper     is x
$clear(name[], value[])
$allowupdate(name[], value[])
i = 0
do while i < $len(attString)
   name[++cnt] = $parse(attString, i, "=")
   name[cnt] = $trim(name[cnt])
   name[cnt] = $uc(name[cnt])
   attString = $seg(attString, i)
   attString = $trim(attString)
   i = 1
   wrapper = $charx(attString, i)
   value[cnt] = $parse(attString, ++i, wrapper)
enddo
end getAtts

'-------------------------------------
'Get the attribute value by attribute name.
' checks for overrides made by calling script
' according to <varname>.<attname> variable
' naming convention.
'-------------------------------------
dynamic function getAttVal(att, name[], value[], varlist[], uhp)[] is x
att      is x
name[]   is x
value[]  is x
varlist[]   is x

uhp      is x
temp[,]   is x
i        is b
j        is b
k        is b
copyptr  is b
'$clear(uhp, temp[], i , j, copyptr, getAttVal[])
$clear(temp[], i, copyptr)
$allowupdate(varlist[],uhp)
copyptr = $varptr(temp[])
i = $find(att, name[], 1, "F")
if i > 0 then
   if $charx(value[i],1) = "@" then
      j = findVar($seg(value[i],2),varlist[])
      if j > 0 then
         (void)$copyvar(j,copyptr)
         if $uc(temp[]) = "NULL" then
            $clear(temp[])
         endif
         getAttVal[] = temp[]
      endif
   else
      getAttVal[1] = value[i]
   endif
endif
if uhp !dp then
   i = $find("UHP", name[], 1, "F")
   j = $find("IDX", name[], 1, "F")
   k = $find("IDX2", name[], 1, "F")
   if i > 0 then
      do while i > 0
         uhp += value[i] + "."
         if j > 0 then uhp += value[j] + "." endif
         if k > 0 then uhp += value[k] + "." endif
         j = $find("IDX", name[], ++i, "F")
         k = $find("IDX2", name[], i, "F")
         i = $find("UHP", name[], i, "F")
      enddo   
   '   uhp += att
   endif
endif
if uhp dp then
   att = uhp + att
'   i = findVar(uhp, varlist[])
   i = findVar(att, varlist[])
   if i > 0 then
      (void)$copyvar(i,copyptr)
      if temp[] dp then
         if $uc(temp[]) = "NULL" then
            $clear(temp[])
         endif
         getAttVal[] = temp[]
      endif
   endif
endif
end getAttVal

      
'-------------------------------------
' return the variable pointer for var
' name
'-------------------------------------
dynamic function findVar(varname, varlist[]) is b
varname     is x
varlist[]   is x
varptr      is b
$allowupdate(varlist[])
varname = $uc(varname)
varptr = $find(varname, varlist[], 1, "F")
if varptr = 0 then
   varptr = $maxarray(varlist[])
endif
do while varlist[varptr] != varname
   (void)$getvar(++varptr,,,,varlist[varptr])
   if varlist[varptr] !dp then
      $clear(findvar)
      return
   endif
enddo
findvar = varptr
end findVar

%preload wrap line-ending(none)
'"
%endpreload